% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sum_time.R
\name{sum_time}
\alias{sum_time}
\alias{vct_sum_time}
\title{Sum time objects}
\usage{
sum_time(..., cycle = NULL, reverse = TRUE, na_rm = FALSE)

vct_sum_time(..., cycle = NULL, reverse = TRUE, na_rm = FALSE)
}
\arguments{
\item{...}{Objects belonging to one of the following classes: \code{Duration},
\code{Period}, \code{difftime}, \code{hms}, \code{POSIXct}, \code{POSIXlt}, or \code{Interval}.}

\item{cycle}{(optional) A \code{numeric} or \code{Duration} object of length 1, equal
or greater than 0, indicating the cycle length in seconds. If \code{NULL} the
function will perform a linear sum (see Details to learn more) (default:
\code{NULL}).}

\item{reverse}{(optional) A \code{logical} value indicating if the function must
use a reverse cycle for negative sums (see Details to learn more) (default:
\code{TRUE}).}

\item{na_rm}{(optional) a \code{logical} value indicating if the function must
remove \code{NA} values while performing the sum (default: \code{FALSE}).}
}
\value{
\itemize{
\item If \code{cycle = NULL}, a \code{Duration} object with a linear sum of the time from
objects in \code{...}.
\item If \code{cycle != NULL}, a \code{Duration} object with a circular sum of the time
from objects in \code{...}.
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#maturing}{\figure{lifecycle-maturing.svg}{options: alt='[Maturing]'}}}{\strong{[Maturing]}}

\code{sum_time()} returns the sum of the time from different kinds of date/time
objects.

\code{vct_sum_time()} returns the vectorized sum of the time from different kinds
of date/time objects.

Both functions can be set to work with a circular time frame (see Details to
learn more).
}
\details{
\subsection{\code{sum_time()} versus \code{vct_sum_time()}}{

\code{sum_time()} behaves similar to \code{\link[base:sum]{base::sum()}}, in the sense that it
aggregates the time lengths of values in \code{...} into a single data point. For
example, \code{sum_time(c(x, y), z)} will have the same output as \code{sum_time(x, y, z)}.

\code{vct_sum_time()} performs a different type of sum (a vectorized one). Instead
of aggregating the time lengths, the function perform a paired sum between
elements. For example, \code{sum_time(c(x, y), c(w, z))} will return a vector like
\code{c(sum_time(x, w), sum_time(y, z))}. Because of that, \code{vct_sum_time()}
requires that all objects in \code{...} have the same length.
}

\subsection{Linear versus circular sum}{

Time can have different "shapes".

If the objective is to measure the duration (time span) of an event, time is
usually measured considering a linear frame, with a fixed point of
\href{https://en.wikipedia.org/wiki/Origin_(mathematics)}{origin}. In this
context, the time value distance itself to infinity in relation to the
origin.\preformatted{                                   B
                             |----------|
                                        A
                             |---------------------|
 - inf                                                inf +
<----------------------------|----------|----------|------->
 s                           0          5          10     s
                           origin

A + B = 10 + 5 = 15s
}

But that's not the only possible "shape" of time, as it can also be measured
in other contexts.

In a "time of day" context, time will be linked to the rotation of the
earth, "resetting" when a new rotation cycle starts. That brings a different
kind of shape to time: a circular shape. With this shape the time value
encounters the origin at the end of each cycle.\preformatted{               - <--- h ---> +
                    origin
                . . . 0 . . .
             .                 .
            .                   .
           .                     .
          .                       .
         .                         .
         18                        6
         .                         .
          .                       .
           .                     .
            .                   .
             .                 .
                . . . 12 . . .

18 + 6 = 0h
}

If we transpose this circular time frame to a linear one, it would look like
this:\preformatted{<----|---------------|---------------|---------------|----->
    0h              12h              0h             12h
  origin                           origin
}

Note that now the origin is not fix, but cyclical.

\code{sum_time()} and \code{vct_sum_time()} can both operate in either a linear or a
circular fashion. If \code{cycle = NULL} (default), the function will use a
linear approach. Else, the function will use a circular approach relative to
the cycle length (e.g, \code{cycle = 86400} (1 day)).
}

\subsection{Fractional time}{

\code{sum_time()} uses the \code{\%\%} operator to cycle values. Hence, it can be subject
to catastrophic loss of accuracy if values in \code{...} are fractional and much
larger than \code{cycle}. A warning is given if this is detected.

\code{\%\%} is a \code{builtin} R function that operates like this:\preformatted{function(a, b) \{
    a - floor(a / b) * b
\}
}
}

\subsection{Negative time cycling}{

If the sum of the time is negative, with a \code{cycle} assigned and
\code{reverse = FALSE}, \code{sum_time()} and \code{vtc_sum_time()} will perform the cycle
considering the absolute value of the sum and return the result with a
negative signal.

However, If the sum of the time have a negative value, with a \code{cycle}
assigned and \code{reverse = TRUE}, \code{sum_time()} and \code{vtc_sum_time()} will perform
the cycle in reverse, relative to its origin.

Example: If the sum of the time have a -30h time span in a reversed cycle of
24h, the result will be 18h. By removing the full cycles of -30h you will
get -6h (-30 + 24), and -6h relative to the origin will be 18h.

\strong{\deqn{- (|-30| \mod 24) + 24 = 18}}\preformatted{               - <--- h ---> +
                    origin
                . . . 0 . . .
              .                 .
            .                   .
           .                     .
          .                       .
         .                         .
    (-6) 18                        6 (-18)
         .                         .
          .                       .
           .                     .
            .                   .
             .                 .
                . . . 12 . . .
                    (-12)
}
}

\subsection{\code{POSIXt} objects}{

\code{\link[base:as.POSIXlt]{POSIXt}} objects in \code{...} will be stripped of their
dates. Only the time will be considered.

Both \code{POSIXct} and \code{POSIXlt} are objects that inherits the class \code{POSIXt}.
Learn more about it in \link[base:DateTimeClasses]{base::DateTimeClasses}.
}

\subsection{\code{Period} objects}{

\code{\link[lubridate:period]{Period}} objects are a special type of object
developed by the \link[lubridate:lubridate-package]{lubridate} team that
represents "human units", ignoring possible timeline irregularities. That is
to say that 1 day as \code{Period} can have different time spans, when looking to
a timeline after a irregularity event. \code{sum_time()} and \code{vct_sum_time()}
ignores that property of \code{Period} objects, treating them like objects of
class \code{\link[lubridate:duration]{Duration}}.

Learn more about \code{Period} objects in the \href{https://r4ds.had.co.nz/dates-and-times.html#periods}{Dates and times} chapter of
Wickham & Grolemund (n.d.).
}

\subsection{\code{Interval} objects}{

By using \code{\link[lubridate:interval]{Interval}} objects in \code{...}, \code{sum_time()}
and \code{vct_sum_time()} will consider only their time lengths. That is, the
amount of seconds of the intervals.

Learn more about \code{Interval} objects in the \href{https://r4ds.had.co.nz/dates-and-times.html#periods}{Dates and times} chapter of
Wickham & Grolemund (n.d.).
}

\subsection{Timeline irregularities}{

This function does not take into account timeline irregularities (e.g.,
leap years, DST, leap seconds). This may not be an issue for most people, but
it must be considered when doing time arithmetic.
}
}
\examples{
## Non-vectorized sum in an linear time frame

x <- c(as.POSIXct("2020-01-01 15:00:00"), as.POSIXct("1999-05-04 17:30:00"))
y <- lubridate::as.interval(lubridate::dhours(7), as.Date("1970-05-08"))
sum_time(x, y)
#> [1] "142200s (~1.65 days)" # 39:30:00 # Expected

## Non-vectorized sum in a circular time frame of 24 hours

x <- c(lubridate::hours(25), lubridate::dhours(5), lubridate::minutes(50))
sum_time(x, cycle = lubridate::ddays())
#> [1] "24600s (~6.83 hours)" # 06:50:00 # Expected

x <- c(hms::parse_hm("00:15"), hms::parse_hm("02:30"), hms::as_hms(NA))
sum_time(x, cycle = lubridate::ddays())
#> NA # Expected
sum_time(x, cycle = lubridate::ddays(), na_rm = TRUE)
#> [1] "9900s (~2.75 hours)" # 02:45:00 # Expected

x <- c(lubridate::hours(-12), lubridate::dhours(-13))
sum_time(x, cycle = lubridate::ddays(), reverse = FALSE)
#> [1] "-3600s (~-1 hours)" # -01:00:00 # Expected

x <- c(lubridate::hours(-12), lubridate::dhours(-13))
sum_time(x, cycle = lubridate::ddays(), reverse = TRUE)
#> [1] "82800s (~23 hours)" # 23:00:00 # Expected

## Vectorized sum in an linear time frame

x <- c(lubridate::dhours(6), NA)
y <- c(hms::parse_hm("23:00"), hms::parse_hm("10:00"))
vct_sum_time(x, y)
#> [1] "104400s (~1.21 days)" NA # 29:00:00 NA # Expected
vct_sum_time(x, y, na_rm = TRUE)
#> [1] "104400s (~1.21 days)" "36000s (~10 hours)" # Expected

## Vectorized sum in a circular time frame of 24 hours

x <- c(lubridate::dhours(6), NA)
y <- c(hms::parse_hm("23:00"), hms::parse_hm("10:00"))
vct_sum_time(x, y, cycle = lubridate::ddays())
#> [1] "18000s (~5 hours)" NA  # Expected
vct_sum_time(x, y, cycle = lubridate::ddays(), na_rm = TRUE)
#> [1] "18000s (~5 hours)"  "36000s (~10 hours)" # Expected

x <- c(lubridate::hours(-49), lubridate::hours(-24))
y <- c(hms::parse_hm("24:00"), - hms::parse_hm("06:00"))
vct_sum_time(x, y, cycle = lubridate::ddays(), reverse = FALSE)
#> "-3600s (~-1 hours)"  "-21600s (~-6 hours)" # Expected

x <- c(lubridate::hours(-49), lubridate::hours(-24))
y <- c(hms::parse_hm("24:00"), - hms::parse_hm("06:00"))
vct_sum_time(x, y, cycle = lubridate::ddays(), reverse = TRUE)
#> "82800s (~23 hours)" "64800s (~18 hours)" # Expected
}
\references{
Wickham, H., & Grolemund, G. (n.d.). \emph{R for data science}. Sebastopol, CA:
O'Reilly Media. Retrieved from \url{https://r4ds.had.co.nz}.
}
\seealso{
Other utility functions: 
\code{\link{assign_date}()},
\code{\link{cycle_time}()},
\code{\link{pretty_mctq}()},
\code{\link{qplot_walk}()},
\code{\link{random_mctq}()},
\code{\link{raw_data}()},
\code{\link{round_time}()},
\code{\link{shorter_interval}()}
}
\concept{utility functions}
